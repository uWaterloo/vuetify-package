import './VGrid.sass';
import Vue from 'vue';
import mergeData from '../../util/mergeData';
import { upperFirst } from '../../util/helpers';
// no xs
const breakpoints = ['sm', 'md', 'lg', 'xl'];
const breakpointProps = (() => {
    return breakpoints.reduce((props, val) => {
        props[val] = {
            type: [Boolean, String, Number],
            default: false,
        };
        return props;
    }, {});
})();
const offsetProps = (() => {
    return breakpoints.reduce((props, val) => {
        props['offset' + upperFirst(val)] = {
            type: [String, Number],
            default: null,
        };
        return props;
    }, {});
})();
const orderProps = (() => {
    return breakpoints.reduce((props, val) => {
        props['order' + upperFirst(val)] = {
            type: [String, Number],
            default: null,
        };
        return props;
    }, {});
})();
const propMap = {
    col: Object.keys(breakpointProps),
    offset: Object.keys(offsetProps),
    order: Object.keys(orderProps),
};
function breakpointClass(type, prop, val) {
    let className = type;
    if (val == null || val === false) {
        return undefined;
    }
    if (prop) {
        const breakpoint = prop.replace(type, '');
        className += `-${breakpoint}`;
    }
    // Handling the boolean style prop when accepting [Boolean, String, Number]
    // means Vue will not convert <v-col sm></v-col> to sm: true for us.
    // Since the default is false, an empty string indicates the prop's presence.
    if (type === 'col' && (val === '' || val === true)) {
        // .col-md
        return className.toLowerCase();
    }
    // .order-md-6
    className += `-${val}`;
    return className.toLowerCase();
}
const cache = new Map();
export default Vue.extend({
    name: 'v-col',
    functional: true,
    props: {
        cols: {
            type: [Boolean, String, Number],
            default: false,
        },
        ...breakpointProps,
        offset: {
            type: [String, Number],
            default: null,
        },
        ...offsetProps,
        order: {
            type: [String, Number],
            default: null,
        },
        ...orderProps,
        alignSelf: {
            type: String,
            default: null,
            validator: (str) => ['auto', 'start', 'end', 'center', 'baseline', 'stretch'].includes(str),
        },
        tag: {
            type: String,
            default: 'div',
        },
    },
    render(h, { props, data, children, parent }) {
        // Super-fast memoization based on props, 5x faster than JSON.stringify
        let cacheKey = '';
        for (const prop in props) {
            cacheKey += String(props[prop]);
        }
        let classList = cache.get(cacheKey);
        if (!classList) {
            classList = [];
            // Loop through `col`, `offset`, `order` breakpoint props
            let type;
            for (type in propMap) {
                propMap[type].forEach(prop => {
                    const value = props[prop];
                    const className = breakpointClass(type, prop, value);
                    if (className)
                        classList.push(className);
                });
            }
            const hasColClasses = classList.some(className => className.startsWith('col-'));
            classList.push({
                // Default to .col if no other col-{bp}-* classes generated nor `cols` specified.
                col: !hasColClasses || !props.cols,
                [`col-${props.cols}`]: props.cols,
                [`offset-${props.offset}`]: props.offset,
                [`order-${props.order}`]: props.order,
                [`align-self-${props.alignSelf}`]: props.alignSelf,
            });
            cache.set(cacheKey, classList);
        }
        return h(props.tag, mergeData(data, { class: classList }), children);
    },
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVkNvbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb21wb25lbnRzL1ZHcmlkL1ZDb2wudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxjQUFjLENBQUE7QUFFckIsT0FBTyxHQUEyQixNQUFNLEtBQUssQ0FBQTtBQUM3QyxPQUFPLFNBQVMsTUFBTSxzQkFBc0IsQ0FBQTtBQUM1QyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sb0JBQW9CLENBQUE7QUFFL0MsUUFBUTtBQUNSLE1BQU0sV0FBVyxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUE7QUFFNUMsTUFBTSxlQUFlLEdBQUcsQ0FBQyxHQUFHLEVBQUU7SUFDNUIsT0FBTyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFO1FBQ3ZDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRztZQUNYLElBQUksRUFBRSxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDO1lBQy9CLE9BQU8sRUFBRSxLQUFLO1NBQ2YsQ0FBQTtRQUNELE9BQU8sS0FBSyxDQUFBO0lBQ2QsQ0FBQyxFQUFFLEVBQTZCLENBQUMsQ0FBQTtBQUNuQyxDQUFDLENBQUMsRUFBRSxDQUFBO0FBRUosTUFBTSxXQUFXLEdBQUcsQ0FBQyxHQUFHLEVBQUU7SUFDeEIsT0FBTyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxFQUFFO1FBQ3ZDLEtBQUssQ0FBQyxRQUFRLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUc7WUFDbEMsSUFBSSxFQUFFLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztZQUN0QixPQUFPLEVBQUUsSUFBSTtTQUNkLENBQUE7UUFDRCxPQUFPLEtBQUssQ0FBQTtJQUNkLENBQUMsRUFBRSxFQUE2QixDQUFDLENBQUE7QUFDbkMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtBQUVKLE1BQU0sVUFBVSxHQUFHLENBQUMsR0FBRyxFQUFFO0lBQ3ZCLE9BQU8sV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsRUFBRTtRQUN2QyxLQUFLLENBQUMsT0FBTyxHQUFHLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHO1lBQ2pDLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7WUFDdEIsT0FBTyxFQUFFLElBQUk7U0FDZCxDQUFBO1FBQ0QsT0FBTyxLQUFLLENBQUE7SUFDZCxDQUFDLEVBQUUsRUFBNkIsQ0FBQyxDQUFBO0FBQ25DLENBQUMsQ0FBQyxFQUFFLENBQUE7QUFFSixNQUFNLE9BQU8sR0FBRztJQUNkLEdBQUcsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQztJQUNqQyxNQUFNLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDaEMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO0NBQy9CLENBQUE7QUFFRCxTQUFTLGVBQWUsQ0FBRSxJQUEwQixFQUFFLElBQVksRUFBRSxHQUE4QjtJQUNoRyxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUE7SUFDcEIsSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLEdBQUcsS0FBSyxLQUFLLEVBQUU7UUFDaEMsT0FBTyxTQUFTLENBQUE7S0FDakI7SUFDRCxJQUFJLElBQUksRUFBRTtRQUNSLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFBO1FBQ3pDLFNBQVMsSUFBSSxJQUFJLFVBQVUsRUFBRSxDQUFBO0tBQzlCO0lBQ0QsMkVBQTJFO0lBQzNFLG9FQUFvRTtJQUNwRSw2RUFBNkU7SUFDN0UsSUFBSSxJQUFJLEtBQUssS0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLEVBQUUsSUFBSSxHQUFHLEtBQUssSUFBSSxDQUFDLEVBQUU7UUFDbEQsVUFBVTtRQUNWLE9BQU8sU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFBO0tBQy9CO0lBQ0QsY0FBYztJQUNkLFNBQVMsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFBO0lBQ3RCLE9BQU8sU0FBUyxDQUFDLFdBQVcsRUFBRSxDQUFBO0FBQ2hDLENBQUM7QUFFRCxNQUFNLEtBQUssR0FBRyxJQUFJLEdBQUcsRUFBaUIsQ0FBQTtBQUV0QyxlQUFlLEdBQUcsQ0FBQyxNQUFNLENBQUM7SUFDeEIsSUFBSSxFQUFFLE9BQU87SUFDYixVQUFVLEVBQUUsSUFBSTtJQUNoQixLQUFLLEVBQUU7UUFDTCxJQUFJLEVBQUU7WUFDSixJQUFJLEVBQUUsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQztZQUMvQixPQUFPLEVBQUUsS0FBSztTQUNmO1FBQ0QsR0FBRyxlQUFlO1FBQ2xCLE1BQU0sRUFBRTtZQUNOLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7WUFDdEIsT0FBTyxFQUFFLElBQUk7U0FDZDtRQUNELEdBQUcsV0FBVztRQUNkLEtBQUssRUFBRTtZQUNMLElBQUksRUFBRSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7WUFDdEIsT0FBTyxFQUFFLElBQUk7U0FDZDtRQUNELEdBQUcsVUFBVTtRQUNiLFNBQVMsRUFBRTtZQUNULElBQUksRUFBRSxNQUFNO1lBQ1osT0FBTyxFQUFFLElBQUk7WUFDYixTQUFTLEVBQUUsQ0FBQyxHQUFRLEVBQUUsRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDO1NBQ2pHO1FBQ0QsR0FBRyxFQUFFO1lBQ0gsSUFBSSxFQUFFLE1BQU07WUFDWixPQUFPLEVBQUUsS0FBSztTQUNmO0tBQ0Y7SUFDRCxNQUFNLENBQUUsQ0FBQyxFQUFFLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFO1FBQzFDLHVFQUF1RTtRQUN2RSxJQUFJLFFBQVEsR0FBRyxFQUFFLENBQUE7UUFDakIsS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLEVBQUU7WUFDeEIsUUFBUSxJQUFJLE1BQU0sQ0FBRSxLQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQTtTQUN6QztRQUNELElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUE7UUFFbkMsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNkLFNBQVMsR0FBRyxFQUFFLENBQUE7WUFDZCx5REFBeUQ7WUFDekQsSUFBSSxJQUEwQixDQUFBO1lBQzlCLEtBQUssSUFBSSxJQUFJLE9BQU8sRUFBRTtnQkFDcEIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDM0IsTUFBTSxLQUFLLEdBQStCLEtBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQTtvQkFDN0QsTUFBTSxTQUFTLEdBQUcsZUFBZSxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUE7b0JBQ3BELElBQUksU0FBUzt3QkFBRSxTQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFBO2dCQUMzQyxDQUFDLENBQUMsQ0FBQTthQUNIO1lBRUQsTUFBTSxhQUFhLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQTtZQUUvRSxTQUFTLENBQUMsSUFBSSxDQUFDO2dCQUNiLGlGQUFpRjtnQkFDakYsR0FBRyxFQUFFLENBQUMsYUFBYSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUk7Z0JBQ2xDLENBQUMsT0FBTyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSTtnQkFDakMsQ0FBQyxVQUFVLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxNQUFNO2dCQUN4QyxDQUFDLFNBQVMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLEtBQUs7Z0JBQ3JDLENBQUMsY0FBYyxLQUFLLENBQUMsU0FBUyxFQUFFLENBQUMsRUFBRSxLQUFLLENBQUMsU0FBUzthQUNuRCxDQUFDLENBQUE7WUFFRixLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQTtTQUMvQjtRQUVELE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLElBQUksRUFBRSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFBO0lBQ3RFLENBQUM7Q0FDRixDQUFDLENBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vVkdyaWQuc2FzcydcblxuaW1wb3J0IFZ1ZSwgeyBWTm9kZSwgUHJvcE9wdGlvbnMgfSBmcm9tICd2dWUnXG5pbXBvcnQgbWVyZ2VEYXRhIGZyb20gJy4uLy4uL3V0aWwvbWVyZ2VEYXRhJ1xuaW1wb3J0IHsgdXBwZXJGaXJzdCB9IGZyb20gJy4uLy4uL3V0aWwvaGVscGVycydcblxuLy8gbm8geHNcbmNvbnN0IGJyZWFrcG9pbnRzID0gWydzbScsICdtZCcsICdsZycsICd4bCddXG5cbmNvbnN0IGJyZWFrcG9pbnRQcm9wcyA9ICgoKSA9PiB7XG4gIHJldHVybiBicmVha3BvaW50cy5yZWR1Y2UoKHByb3BzLCB2YWwpID0+IHtcbiAgICBwcm9wc1t2YWxdID0ge1xuICAgICAgdHlwZTogW0Jvb2xlYW4sIFN0cmluZywgTnVtYmVyXSxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIH1cbiAgICByZXR1cm4gcHJvcHNcbiAgfSwge30gYXMgRGljdGlvbmFyeTxQcm9wT3B0aW9ucz4pXG59KSgpXG5cbmNvbnN0IG9mZnNldFByb3BzID0gKCgpID0+IHtcbiAgcmV0dXJuIGJyZWFrcG9pbnRzLnJlZHVjZSgocHJvcHMsIHZhbCkgPT4ge1xuICAgIHByb3BzWydvZmZzZXQnICsgdXBwZXJGaXJzdCh2YWwpXSA9IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICBkZWZhdWx0OiBudWxsLFxuICAgIH1cbiAgICByZXR1cm4gcHJvcHNcbiAgfSwge30gYXMgRGljdGlvbmFyeTxQcm9wT3B0aW9ucz4pXG59KSgpXG5cbmNvbnN0IG9yZGVyUHJvcHMgPSAoKCkgPT4ge1xuICByZXR1cm4gYnJlYWtwb2ludHMucmVkdWNlKChwcm9wcywgdmFsKSA9PiB7XG4gICAgcHJvcHNbJ29yZGVyJyArIHVwcGVyRmlyc3QodmFsKV0gPSB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzXG4gIH0sIHt9IGFzIERpY3Rpb25hcnk8UHJvcE9wdGlvbnM+KVxufSkoKVxuXG5jb25zdCBwcm9wTWFwID0ge1xuICBjb2w6IE9iamVjdC5rZXlzKGJyZWFrcG9pbnRQcm9wcyksXG4gIG9mZnNldDogT2JqZWN0LmtleXMob2Zmc2V0UHJvcHMpLFxuICBvcmRlcjogT2JqZWN0LmtleXMob3JkZXJQcm9wcyksXG59XG5cbmZ1bmN0aW9uIGJyZWFrcG9pbnRDbGFzcyAodHlwZToga2V5b2YgdHlwZW9mIHByb3BNYXAsIHByb3A6IHN0cmluZywgdmFsOiBib29sZWFuIHwgc3RyaW5nIHwgbnVtYmVyKSB7XG4gIGxldCBjbGFzc05hbWUgPSB0eXBlXG4gIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIGlmIChwcm9wKSB7XG4gICAgY29uc3QgYnJlYWtwb2ludCA9IHByb3AucmVwbGFjZSh0eXBlLCAnJylcbiAgICBjbGFzc05hbWUgKz0gYC0ke2JyZWFrcG9pbnR9YFxuICB9XG4gIC8vIEhhbmRsaW5nIHRoZSBib29sZWFuIHN0eWxlIHByb3Agd2hlbiBhY2NlcHRpbmcgW0Jvb2xlYW4sIFN0cmluZywgTnVtYmVyXVxuICAvLyBtZWFucyBWdWUgd2lsbCBub3QgY29udmVydCA8di1jb2wgc20+PC92LWNvbD4gdG8gc206IHRydWUgZm9yIHVzLlxuICAvLyBTaW5jZSB0aGUgZGVmYXVsdCBpcyBmYWxzZSwgYW4gZW1wdHkgc3RyaW5nIGluZGljYXRlcyB0aGUgcHJvcCdzIHByZXNlbmNlLlxuICBpZiAodHlwZSA9PT0gJ2NvbCcgJiYgKHZhbCA9PT0gJycgfHwgdmFsID09PSB0cnVlKSkge1xuICAgIC8vIC5jb2wtbWRcbiAgICByZXR1cm4gY2xhc3NOYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuICAvLyAub3JkZXItbWQtNlxuICBjbGFzc05hbWUgKz0gYC0ke3ZhbH1gXG4gIHJldHVybiBjbGFzc05hbWUudG9Mb3dlckNhc2UoKVxufVxuXG5jb25zdCBjYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBhbnlbXT4oKVxuXG5leHBvcnQgZGVmYXVsdCBWdWUuZXh0ZW5kKHtcbiAgbmFtZTogJ3YtY29sJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICBjb2xzOiB7XG4gICAgICB0eXBlOiBbQm9vbGVhbiwgU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgfSxcbiAgICAuLi5icmVha3BvaW50UHJvcHMsXG4gICAgb2Zmc2V0OiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICB9LFxuICAgIC4uLm9mZnNldFByb3BzLFxuICAgIG9yZGVyOiB7XG4gICAgICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICB9LFxuICAgIC4uLm9yZGVyUHJvcHMsXG4gICAgYWxpZ25TZWxmOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgdmFsaWRhdG9yOiAoc3RyOiBhbnkpID0+IFsnYXV0bycsICdzdGFydCcsICdlbmQnLCAnY2VudGVyJywgJ2Jhc2VsaW5lJywgJ3N0cmV0Y2gnXS5pbmNsdWRlcyhzdHIpLFxuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnZGl2JyxcbiAgICB9LFxuICB9LFxuICByZW5kZXIgKGgsIHsgcHJvcHMsIGRhdGEsIGNoaWxkcmVuLCBwYXJlbnQgfSk6IFZOb2RlIHtcbiAgICAvLyBTdXBlci1mYXN0IG1lbW9pemF0aW9uIGJhc2VkIG9uIHByb3BzLCA1eCBmYXN0ZXIgdGhhbiBKU09OLnN0cmluZ2lmeVxuICAgIGxldCBjYWNoZUtleSA9ICcnXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzKSB7XG4gICAgICBjYWNoZUtleSArPSBTdHJpbmcoKHByb3BzIGFzIGFueSlbcHJvcF0pXG4gICAgfVxuICAgIGxldCBjbGFzc0xpc3QgPSBjYWNoZS5nZXQoY2FjaGVLZXkpXG5cbiAgICBpZiAoIWNsYXNzTGlzdCkge1xuICAgICAgY2xhc3NMaXN0ID0gW11cbiAgICAgIC8vIExvb3AgdGhyb3VnaCBgY29sYCwgYG9mZnNldGAsIGBvcmRlcmAgYnJlYWtwb2ludCBwcm9wc1xuICAgICAgbGV0IHR5cGU6IGtleW9mIHR5cGVvZiBwcm9wTWFwXG4gICAgICBmb3IgKHR5cGUgaW4gcHJvcE1hcCkge1xuICAgICAgICBwcm9wTWFwW3R5cGVdLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgICAgY29uc3QgdmFsdWU6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gPSAocHJvcHMgYXMgYW55KVtwcm9wXVxuICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGJyZWFrcG9pbnRDbGFzcyh0eXBlLCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lKSBjbGFzc0xpc3QhLnB1c2goY2xhc3NOYW1lKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBoYXNDb2xDbGFzc2VzID0gY2xhc3NMaXN0LnNvbWUoY2xhc3NOYW1lID0+IGNsYXNzTmFtZS5zdGFydHNXaXRoKCdjb2wtJykpXG5cbiAgICAgIGNsYXNzTGlzdC5wdXNoKHtcbiAgICAgICAgLy8gRGVmYXVsdCB0byAuY29sIGlmIG5vIG90aGVyIGNvbC17YnB9LSogY2xhc3NlcyBnZW5lcmF0ZWQgbm9yIGBjb2xzYCBzcGVjaWZpZWQuXG4gICAgICAgIGNvbDogIWhhc0NvbENsYXNzZXMgfHwgIXByb3BzLmNvbHMsXG4gICAgICAgIFtgY29sLSR7cHJvcHMuY29sc31gXTogcHJvcHMuY29scyxcbiAgICAgICAgW2BvZmZzZXQtJHtwcm9wcy5vZmZzZXR9YF06IHByb3BzLm9mZnNldCxcbiAgICAgICAgW2BvcmRlci0ke3Byb3BzLm9yZGVyfWBdOiBwcm9wcy5vcmRlcixcbiAgICAgICAgW2BhbGlnbi1zZWxmLSR7cHJvcHMuYWxpZ25TZWxmfWBdOiBwcm9wcy5hbGlnblNlbGYsXG4gICAgICB9KVxuXG4gICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGNsYXNzTGlzdClcbiAgICB9XG5cbiAgICByZXR1cm4gaChwcm9wcy50YWcsIG1lcmdlRGF0YShkYXRhLCB7IGNsYXNzOiBjbGFzc0xpc3QgfSksIGNoaWxkcmVuKVxuICB9LFxufSlcbiJdfQ==